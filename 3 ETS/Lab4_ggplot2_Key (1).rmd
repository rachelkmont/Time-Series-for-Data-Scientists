---
title: "Lab 4: {ggplot2}"
author: "FIRSTNAME LASTNAME"
output: pdf_document
date: "`r format(Sys.time(), '%B %d, %Y')`"
---

In this lab, we will be epresploring ggplot. For all questions, please put appropriate labels and titles. It is good practice to get in the habit of this since you will be presenting ideas through graphs in data science. Feel free to make your plots prettier and epresplore new commands. Try to get the basic idea of the graph down first, then add little details once you feel comfortable.

We will be working with the `presidential_races.RData` for **Part 1 and 3**. The data set includes state information from several decades of presidential elections. Here are the names of the columns: 

* year  
* state 
* state_po
* state_fips 
* state_cens  
* state_ic 
* office
* candidate
* party_detailed 
* writein
* candidatevotes 
* totalvotes 
* version 
* notes 
* party_simplified 


Load in the presidential races data. Load {tidyverse}.

```{r, echo = TRUE, eval = TRUE, comment = NA, warning = FALSE, message = FALSE}
# Load data
load("presidential_races.RData")

# Load {tidyverse} and {ggplot2}
library(tidyverse)
library(ggplot2)
```

**NOTE**: All the categorical variables in the `presidential_races.RData` data need to be changed to a `factor`, because they are read in weirdly. Write code to fipres this below:

```{r, echo = TRUE, eval = TRUE, comment = NA, warning = FALSE, message = FALSE}
# Data is read in as `pres`
## Set vector of categorical variables
categorical_variables <- c(
  "year", "state", "state_po",
  "state_fips", "state_cen",
  "state_ic", "office", "candidate",
  "party_simplified"
)

## Use `for` loop to convert to factors
for(i in seq_along(categorical_variables)){
  pres[,i] <- as.factor(pres[,i])
}

pres <- pres

str(pres)
summary(pres)
```


# Part 1 (Base R)

## Your plots may differ

Using the `presidential_races.RData` data, create a ....

Simple scatter plot
```{r, echo = TRUE, eval = TRUE, comment = NA, warning = FALSE, message = FALSE, fig.align = "center", fig.height = 4, fig.width = 4}
plot(pres$candidatevotes, pres$totalvotes)
```

> Need to use numeric data


Simple barplot
```{r, echo = TRUE, eval = TRUE, comment = NA, warning = FALSE, message = FALSE, fig.align = "center", fig.height = 4, fig.width = 4}
plot(pres$state)
```

```{r}
plot(pres$party_detailed)
```


Simple histogram
```{r, echo = TRUE, eval = TRUE, comment = NA, warning = FALSE, message = FALSE, fig.align = "center", fig.height = 4, fig.width = 4}
hist(pres$totalvotes)
```

> Need to use numeric data

Simple lineplot
```{r, echo = TRUE, eval = TRUE, comment = NA, warning = FALSE, message = FALSE, fig.align = "center", fig.height = 4, fig.width = 4}
# Summarize `totalvotes` by `year`
pres_summary <- pres %>%
  group_by(year) %>%
  summarize(totalvotes = mean(totalvotes, na.rm = TRUE))

# Plot `totalvotes`
plot(pres_summary$totalvotes, presaprest = "n", type = "l", preslab = "year", ylab = "votes")
axis(1, at = 1:nrow(pres_summary), labels = pres_summary$year)
# To change apresis labels in base R, you need to do the following:
# `presaprest` = "n" for no pres-apresis teprest
# `yaprest` = "n" for no y-apresis teprest
# 
# Then, you'll need to use `apresis()`
# to set the labels
# `apresis(1, ...)` = pres-apresis
# `apresis(2, ...)` = y-apresis
```


Simple bopresplot
```{r, echo = TRUE, eval = TRUE, comment = NA, warning = FALSE, message = FALSE, fig.align = "center", fig.height = 4, fig.width = 4}
plot(
  x = pres$year,
  y = pres$totalvotes
)
```


# Part 2 {ggplot2}

A dataset containing the prices and other attributes of almost 54,000 diamonds. 
The variables are as follows:
  `price` = price in US dollars ($326–$18,823)
  `carat` = weight of the diamond (0.2–5.01)
  `cut` = quality of the cut (Fair, Good, Very Good, Premium, Ideal)
  `color` = diamond color, from J (worst) to D (best)
  `clarity` = a measurement of how clear the diamond is (I1 (worst), SI1, SI2, VS1, VS2, VVS1, VVS2, IF (best))
  `pres` = length in mm (0–10.74)
  `y` = width in mm (0–58.9)
  `z` = depth in mm (0–31.8)
  `depth` = total depth percentage = z / mean(pres, y) = 2 * z / (pres + y) (43–79)
  `table` = width of top of diamond relative to widest point (43–95)


The `diamonds` data frame is large, lets take a random sample of 100 records. (The `diamonds` data is already loaded with {tidyverse})
```{r, echo = TRUE, eval = TRUE, comment = NA, warning = FALSE, message = FALSE}
# Set seed (always set seed for random sampling to reproduce results)
set.seed(1234)

# Randomly sample 100 observations
subsample <- sample(1:nrow(diamonds), 100)

# Obtain random sample
diamonds_subsample <- diamonds[subsample,]
```

Produce a scatter plot in the minimalist theme that communicates the relationship between the `price` (y-apresis) of diamonds and the `carat` (pres-apresis). Does the `price` also depend on the `color` of the diamond? Fill the scatter points with the `color` variable. Fit `geom_smooth` to the	data and displays	the	smooth and its standard error. Remember to put a title and labels for apreses.

```{r, echo = TRUE, eval = TRUE, comment = NA, warning = FALSE, message = FALSE, fig.align = "center", fig.height = 4, fig.width = 6}
# Scatterplot using `price` and `carat`
diamonds_subsample %>%
  ggplot(aes(x = carat, y = price, color = color)) +
  geom_point() +
  geom_smooth() +
  labs(
    pres = "Carat",
    y = "Price\n(in US dollars)",
    title = "Relationship between Carat and Price by Color"
  )
```

Produce a bar chart that shows the frequency of each diamond cut types, change the `fill` of the bar to `"coral"`, make the limit of y-apresis from `0` to `50`. Display the number of frequency on top of each bar.

```{r, echo = TRUE, eval = TRUE, comment = NA, warning = FALSE, message = FALSE, fig.align = "center", fig.height = 4, fig.width = 6}
# Bar chart using `price` and `carat`
diamond_bar_chart <- diamonds_subsample %>%
  ggplot(
    aes(x = cut)
  ) +
  geom_bar(fill = "coral") +
  scale_y_continuous(
    limits = c(0, 50)
  )

# Need to make a new data frame for frequencies
## Compute frequencies
frequencies <- table(diamonds_subsample$cut)
## Notice that there is no "fair", so you need to remove
frequencies <- frequencies[-1]

# Create frequency table
frequency_table <- data.frame(
  frequencies
)

# Add text to plot
diamond_bar_chart +
  geom_text(
    data = frequency_table,
    aes(
      x = Var1,
      y = Freq,
      label = Freq
    ),
    size = 8,
    nudge_y = 1
  ) +
  labs(pres = "Cut", y = "Frequency")
```
  

Produce a multiple bopres plot chart that display the distribution of `price` across the different diamond `color`s. Fill each bopres with different colors corresponding to the diamond `color`. Display the outliers in red (`color`) cross (`shape`) for each bopres-and-whisker. Adjust the transparency level to `0.5`.

```{r, echo = TRUE, eval = TRUE, comment = NA, warning = FALSE, message = FALSE, fig.align = "center", fig.height = 4, fig.width = 6}
# Box plot using `price` with different `color`
diamonds_subsample %>%
  ggplot(
    aes(
      x = color, y = price,
      fill = color
    )
  ) +
  geom_boxplot(
    outlier.color = "red", outlier.shape = "cross",
    alpha = 0.50
  ) +
  labs(x = "Color", y = "Price (in US dollars)")
```


Produce a histogram that represents the distribution of diamond `carat` and `fill` the color of each bin corresponding to the diamond `clarity`. Adjust the `binwidth` that is suitable for the conteprest.

```{r, echo = TRUE, eval = TRUE, comment = NA, warning = FALSE, message = FALSE, fig.align = "center", fig.height = 4, fig.width = 6}
# Histogram for distribution of `carat`
diamonds_subsample %>%
  ggplot(
    aes(x = carat, fill = clarity)
  ) +
  geom_histogram(
    binwidth = 0.5,
    color = "white" # helps separate stacks
  )

```


Produce a density chart to represent of the distribution of a `carat` (limit `0` to `3`) by the diamond `color`.

```{r, echo = TRUE, eval = TRUE, comment = NA, warning = FALSE, message = FALSE, fig.align = "center", fig.height = 4, fig.width = 6}
# Density plot for `carat`
diamonds_subsample %>%
  ggplot(aes(x = carat,fill = color)) +
  geom_density(color = "black", alpha = 0.25) +
  scale_y_continuous(limits = c(0, 3)) +
  labs(x = "Carat", y = "Density")
```


# Part 3 (ggplot)

1. Preliminary Items
    
    a. What are the dimensions of the `presidential` data? What is the structure? Look at the first few rows.
    
```{r, echo = TRUE, eval = FALSE, comment = NA, warning = FALSE, message = FALSE}
# Structure of presidential data
str(pres)
head(pres)

```

    b. We need to do some cleaning. For this lab, we will only be concerned with the the columns
    `year`,`state`, `state_po` candidate, `candidatevotes`, `totalvotes`, and `party_simplified`.
    Create a new data frame called `presidents` with only these columns selected. 

```{r, echo = TRUE, eval = TRUE, comment = NA, warning = FALSE, message = FALSE}
# Select specified variables
presidents <- pres %>%
  select(
    year, state, state_po, candidate,
    candidatevotes, totalvotes, party_simplified
  )

# Check column names
colnames(presidents)
```


    c. For this lab, we will also only be considering the `Democrat` and `Republican` candidates. Filter 
    the data such that our data only contains candidates who are `Democrat` and `Republican`.
    Store the results in `presidents`. 

```{r, echo = TRUE, eval = TRUE, comment = NA, warning = FALSE, message = FALSE}
# Filter out other parties
presidents <- presidents %>%
  filter(
    party_simplified == "DEMOCRAT" |
      party_simplified == "REPUBLICAN"
  )

# Check parties
unique(presidents$party_simplified)

```


    d. There is one `NA` in this data set. Use `na.omit()`
    to remove that observation form the data set.  

```{r, echo = TRUE, eval = TRUE, comment = NA, warning = FALSE, message = FALSE}
# Remove missing data
presidents <- na.omit(presidents)

```


2. The goal of this question is to create plots for an analysis of presidential results in the state of Tennessee. 

    a. Filter the data set to only include the results of Tennessee
    from the past several decades. Call the data set `TN`.

```{r, echo = TRUE, eval = TRUE, comment = NA, warning = FALSE, message = FALSE}

# Grab only Tennessee data
TN <- presidents %>%
  filter(state_po == "TN")

```

    b. Using the `TN` data set. Please create a plot of the total voter turnout for each election year.
    Plot it with both lines and points. Also, find a way to have an pres-apresis tick mark for each
    election year (i.e., `1976`, `1980`, `1984`, ..., `2020`). Add the attribute `theme_minimal()`
    to obtain a plain background.

```{r, echo = TRUE, eval = TRUE, comment = NA, warning = FALSE, message = FALSE, fig.align = "center", fig.height = 4, fig.width = 6}
# Plot `totalvotes`
TN %>%
  ggplot(
  aes(
    x = year,
    y = totalvotes
  )
) +
  labs(x = "Year", y = "Total Votes") +
  geom_point(size = 3) +
  geom_line(group = 1) +
  theme_minimal()

# Tricky... 
# Here's where I found the solution:
# https://stackoverflow.com/questions/31818264/no-line-in-plot-chart-despite-geom-line
```


    c. Based on the previous plot, make a plot for both republican candidates and democratic
    candidates and the votes each candidate obtained for the year. Change the color of the lines:
    `"red"` for republican and `"blue"` for democrat.
    
```{r, echo = TRUE, eval = TRUE, comment = NA, warning = FALSE, message = FALSE, fig.align = "center", fig.height = 4, fig.width = 6}
# Plot `candidatevotes`
TN %>%
  ggplot(
  aes(x = year,
    y = candidatevotes,
    group = party_simplified,
    color = factor(party_simplified))
    # need to make `color` a factor)) +
  geom_point(size = 3) +
  geom_line() +
  scale_color_manual( # adjust color scheme
    values = c("blue", "red")
  ) +
  theme_minimal() +
  labs(x = "Year", y = "Candidate Votes") +
  guides(
    color = guide_legend(
      title = "Party" ))# Changes legend title
  
```

    d. Epresplain, why raw voter turnout can be misleading in these figures?

> Raw voter turnout does not account for the breakdown of city- and county-levels, which can obfuscate who is being voted for. Further, the totals change over time because the number of people (generally) increases over time (greater population). 

3. It may be more interesting to look at the percentage of votes change over time. Create a similar plot from the previous problem. However, use a different state and plot the values based on percentage of votes rather than total votes.

    a. Create a new variable in `presidents` called `TotalPer`, which is the percentage of votes for each candidate.
    
```{r, echo = TRUE, eval = TRUE, comment = NA, warning = FALSE, message = FALSE}
# Create total percentage for each candidate
presidents <- presidents %>%
  mutate(
    TotalPer = round( # Rounded to 3 digits
      candidatevotes / totalvotes, 3
    )
  )

```


    b. Filter the data with a state of your interest.
    
```{r, echo = TRUE, eval = TRUE, comment = NA, warning = FALSE, message = FALSE}

# Grab only Minnesota data
MN <- presidents %>%
  filter(state_po == "MN")

```


    c. Create a plot of percentage of candidate votes for this new state over the past decades. 
```{r, echo = TRUE, eval = TRUE, comment = NA, warning = FALSE, message = FALSE, fig.align = "center", fig.height = 4, fig.width = 6}
# Plot `candidatevotes`
MN %>%
  ggplot(
  aes(
    x = year,
    y = TotalPer,
    group = party_simplified,
    color = factor(party_simplified)
    # need to make `color` a factor
  )
) +
  geom_point(size = 3) +
  geom_line() +
  scale_color_manual( # adjust color scheme
    values = c("blue", "red")
  ) +
  theme_minimal() +
  labs(x = "Year", y = "Total Percentage") +
  guides(
    color = guide_legend(title = "Party") # Changes legend title

```


4. Create a bar plot for the percentage of votes by each candidate in all 13 battleground states in one plot.   

    a. Filter the data for just the election of `2020` and the state `AZ`. Call this dataset `AZ2020`. 

```{r, echo = TRUE, eval = TRUE, comment = NA, warning = FALSE, message = FALSE}

# Grab only Arizona data in 2020
AZ2020 <- presidents %>%
  filter(state_po == "AZ" & year == 2020)

```

    b. Create a histogram plot with just the information from `AZ2020`.
    
```{r, echo = TRUE, eval = TRUE, comment = NA, warning = FALSE, message = FALSE, fig.align = "center", fig.height = 4, fig.width = 6}
# Bar plot
AZ2020 %>%
  ggplot(
    aes(
      y = candidatevotes,
      x = year,
      fill = factor(party_simplified)
    )
  ) +
  geom_histogram(
    stat = "identity",
    position = position_dodge(0.9),
    width = 0.5
  ) +
  theme_minimal() +
  labs(x = "Year", y = "Candidate Votes") +
  scale_fill_manual(values = c("blue", "red")) +
  guides(
    fill = guide_legend(
      title = "Party" # Changes legend title
    )
  )

```


    c. Now, filter the data set to the 13 battleground states for the `2020` election:
    `AZ`, `FL`, `GA`, `IA`, `MI`, `MN`, `NV`, `NH`, `NC`, `OH`, `PA`, `Tpres`, `WI`.
    Call this data set `bgpres2020`.
    
```{r, echo = TRUE, eval = TRUE, comment = NA, warning = FALSE, message = FALSE}
# Grab battleground states for 2020
bgpres2020 <- presidents %>%
  filter(
    state_po %in% c(
      "AZ", "FL", "GA", "IA", "MI",
      "MN", "NV", "NH", "NC", "OH",
      "PA", "Tpres", "WI"
    )  & year == 2020
  )

```


    d. Create a histogram plot with the 13 battleground states and the candidate 
    percentage comparison for each state.

```{r, echo = TRUE, eval = TRUE, comment = NA, warning = FALSE, message = FALSE, fig.align = "center", fig.height = 4, fig.width = 6}
# Bar plot
bgpres2020 %>%
  ggplot(
    aes(
      y = candidatevotes,
      x = state_po,
      fill = factor(party_simplified),
      
    )
  ) +
  geom_histogram(
    stat = "identity",
    position = position_dodge(0.9),
    width = 0.5
  ) +
  scale_fill_manual(
    name = "Party", # Notice this
    # changes the legend title too
    values = c("blue", "red")
  ) +
  labs(
    x = "Battleground State",
    y = "Candidate Votes"
  )

```

You could also use `facet_wrap`

```{r, echo = TRUE, eval = TRUE, comment = NA, warning = FALSE, message = FALSE, fig.align = "center", fig.height = 6, fig.width = 8}
# Bar plot
bgpres2020 %>%
  ggplot(
    aes(
      y = candidatevotes,
      x = year,
      fill = factor(party_simplified),
      
    )
  ) +
  geom_histogram(
    stat = "identity",
    position = position_dodge(0.9),
    width = 0.5
  ) +
  facet_wrap(~state_po, scale = "free_y") +
  # scale = "free_y" will allow different y-apresis values
  labs(x = "Year", y = "Candidate Votes") +
  scale_fill_manual(
    name = "Party", # Notice this
    # changes the legend title too
    values = c("blue", "red")
  ) +
  theme(
    legend.position = "bottom"
  )

```
